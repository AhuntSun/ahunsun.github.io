# 第六讲：Git协作与Git pull常见问题

## 前言

`git`除了可以很好地管理个人项目外，最大的一个用处就是实现团队协作开发。况且，`linus`大神开发`git`的初衷就是为了维护`Linux`内核这一开源项目。所以，熟悉使用`git`进行多人协作开发的一般步骤和方法具有十分重要的意义。这一讲将会为你介绍使用`git`进行团队协作开发的一般方式以及`git pull`操作常见问题的解决方法。

## 一、`git`协作方式

### 1.常见开发模式

* `Gitflow`：简单来说，就是多种开发模式的总称。例如：使用多少分支，什么时候合并分支等等。这方面篇幅较长，内容较多，之后会进行详细讲解；

* 基于`Git`分支的开发模型：一般最少有三个分支：

  * `develop`分支：频繁变化的分支，供开发人员之间进行协作开发，文件推送与合并；
  * `test`分支：供测试人员与产品等人员使用的一个分支，变化不是特别频繁；
  * `master`分支：生产发布分支，变化非常不频繁的一个分支（一般有权限设置，因为直接与生产有关）；
  * `bugfix(hotfix)`分支：用于紧急修复的分支；当出现紧急`bug`时，在常规的`develop`分支上修复已经赶不上了。此时可以直接将`master`分支的代码拉取到`bugfix`分支上，进行`bug`修复，修复完之后，再将它合并到`master`分支上发布；

  合并方向为：`develop` -> `test` -> `master`

### 2.`SVN`方式（典型模型）

![image-20200416135410464]( http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/1.png)

首先有两位用户`A`与`B`，`A`的本地仓库**不为空**，`B`的仓库**为空**，还有一个远程仓库`C`。

* `A`首先将本地仓库的代码推送（`push`）到`C`中，此时`A`和`C`两个仓库的文件一致，如图中`1`所示；
* 随后`B`将`C`的代码拉取（`pull`）下来，如图中`2`所示，此时`A`，`B`，`C`三个仓库中的文件一致；随后`A`，`B`继续在本地进行开发，并向各自的本地仓库进行了数次提交；
* 此时，`A`先向`C`推送修改过后的本地仓库文件，由于这是远程仓库`C`的首次修改，`C`中的文件`A`中都有，所以可以直接推送，不用先执行`git pull`，如图中`3`所示；
* 随后，在`B`将修改过的本地仓库文件推送到`C`的过程中会出现错误。原因在于：此时的`C`中有`A`做出的修改，不能让`B`进行覆盖，此时`B`要想成功推送，应该先将`C`中的文件拉取（`pull`）到本地；如图中`4`所示，拉取时有两种情况：
  * **成功**：说明`A`与`B`修改的不是同一个文件，采用`Fast-forward`方式自动合并；
  * **失败**：说明`A`与`B`修改了同一个文件，需要手动解决冲突并合并；
* `B`成功将`C`中的文件拉取到本地合并后，就能将`B`对本地仓库所做的修改推送（`push`）到远程仓库`C`了，如图中的`5`所示；

在整个过程中，可以发现远程仓库`C`仅仅是起到**代码第三方托管**的作用；

### 3.模拟多人协作

为了模拟多用户协作，可以使用`--local`来设置每个仓库的用户信息：

```
git config --local user.name '张三'
```

`--local`是一个配置作用域的参数，其他的还有：

* `--global `：作用域为每个计算机用户，优先度第二，实际上常用这个参数进行配置；
* `--system `：作用域为整个系统，优先级最低；

可以使用：`git clone`将远程仓库的代码下载到本地某文件夹中，下面使用的是`SSH`的方式：

![image-20200328170839067](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/2.png)

还可以通过在链接后面加上一个字符串，重新命名下载到本地的远程仓库文件的名字：

```
git clone git@gitee.com:ahuntsun/MY.git mygit2
```

![image-20200328171302207](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/3.png)

### 4.协作的本质

远程仓库通常有多个分支，而在本地仓库进行一次推送时**并不是将本地仓库的所有分支都推送到远程仓库**，而是选择本地仓库中的一个分支，将其推送到远程仓库的其中一个分支上：

![image-20200411182057807](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/4.png)

比如本地的`master`分支，如上图所示，可以选择远程仓库的`master、dev、test`其中一条分支进行推送。假如想要推送到远程仓库的`master`分支，如果一开始两个分支没有任何联系，自然要：

* ①先建立本地`master`分支与远程`master`分支的关联（至于如何建立关联，下一节将会详细讲解）；
* ②通过本地`master`分支与远程`master`分支的合并，使两条分支的内容第一次达到同步；
* ③在本地`master`分支上进行修改，然后将修改推送到对应的远程`master`分支上。此时，两分支的内容第二次达到同步；

## 二、`git pull`

在实际开发中，在推送代码前，往往都要先执行一次`git pull`将远程仓库的代码拉取到本地并进行合并；从前面的学习中我们知道：`git pull = git fetch + git merge`：

* `git fetch`：表示将远程仓库的所有文件拉取到本地版本库；
* `git merge`：将远程仓库中的文件与本地仓库中的文件进行合并；

但是，在执行`git pull`命令时，由于本地仓库与远程仓库历史提交记录的不同，往往会出现各种各样的合并错误；在分析这些错误之前，首先搭建测试环境：

分别创建两个本地仓库`mygit`和`mygit2`，并且这两个本地仓库与同一个远程仓库建立联系，如下图所示：

![image-20200416141016230](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/5.png)

### 1.不发生合并冲突

在本地仓库`mygit2`中使用`--local`参数配置新的用户`lisi`模拟多人协作，随后通过`lisi`给远程仓库推送一个新的文件。回到`mygit`后执行`git remote show origin`指令，会显示如下信息：

![image-20200328172158711](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/6.png)

表示，本地仓库`mygit`相对于远程仓库而言已经过时了，即远程仓库中有`mygit2`推送的，`mygit`中没有的文件；此时可以在`mygit`中执行`git pull`，将远程仓库中的文件拉取到本地仓库`mygit`中进行合并：

![image-20200328172428901](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/7.png)

上图中的第二个箭头表示，在`pull`操作的过程中`mygit`中的`master`分支与远程仓库中的`master`分支采用`Fast-forward`方式进行了合并，并达到了同步。

> 这里的本地远程分支`origin/master`代表着远程`master`分支，关于本地远程分支将会在下一节进行详细讲解；

关于`Fast-forward`方式之前已经介绍过了，在上述合并过程中`origin/master`分支直接指向了最新提交，中间没有其他分支，也就不会出现合并冲突，这种合并方式称为**快进**。如下图所示：

![image-20200407142030574](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/8.png)

这是一个理想的情况，很多情况下执行`git pull`操作时，都会出现合并冲突，需要解决冲突，再进行手动合并；

### 2.`git pull`同源合并冲突

所谓同源，指的是本地仓库与远程仓库中的分支从根提交节点开始，有共同的提交历史；简而言之，有共同的根提交节点的两个分支称为同源；如下图所示，两仓库中的`master`分支有共同的根提交节点`A`，所以这两个仓库的`master`分支是同源的：

![image-20200410115057180](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/9.png)

这种情况下`git pull`出现的错误为自动合并失败，比如都同时修改了`develop.txt`文件，错误信息如下：

```
Auto-merging develop.txt
CONFLICT (content): Merge conflict in develop.txt
Automatic merge failed; fix conflicts and then commit the result.
```

#### 错误原因

具体情况模拟如下：

在`mygit`中修改`hello.txt`文件的第二行为`1`，在`mygit2`中修改`hello.txt`文件的第二行为`2`，即对同一文件的同一处进行了修改。

此时取决于谁先进行`git push`操作，若`mygit`先将修改后的`hello.txt`推送到远程仓库。那么当`mygit2`再进行推送时会出现如下错误：

![image-20200328173921075](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/10.png)

提示信息表明：远程仓库中有一些文件是你没有的，无法更新远程仓库；这是因为，`mygit`先把修改的`hello.txt`推送到了远程仓库；此时`mygit2`想要成功进行推送，需要先将远程仓库中经过`mygit`修改的`hello.txt`与本地仓库的`hello.txt`进行合并。

#### 解决方案

可以使用`git pull`来解决这一问题，那么我们首先执行一次`git pull`操作：

![image-20200328174312298](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/11.png)

可以发现`git pull`指令在进行自动合并时发生了错误，这是因为`mygit`和`mygit2`都对`hello.txt`的同一个地方做了修改，`git`不知道以谁为准，所以会导致自动合并失败，此时需要通过**解决冲突三步曲**来手动合并：

**第一步：**

打开冲突文件`hello.txt`可以看到典型的冲突文件显示方式：

![image-20200328180835818](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/12.png)

箭头`<<<`与`>>>`范围内表示的是发生冲突的位置。`2`是`mygit2`对`hello.txt`的修改，`1`为远程仓库中`hello.txt`的内容；

经过协商后，留下第`3`行，其余删除：

![image-20200328181200775](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/13.png)

由此手动合并了对文件`hello.txt`的修改，解决了冲突。

> `vim`指令补充：通过`esc`进入命令行模式后，通过上下方向键选中某一行，再双击`d`就可以删除光标所在的行；删除多行时，在命令行中输入`:2,4d`表示删除第`2~4`行；

**第二步：**

再次查看状态：

![image-20200328181841135](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/14.png)

发现`hello.txt`处于工作区，`git`提示我们要通过`git add`指令将解决冲突时对`hello.txt`所做的修改纳入暂存区。

**第三步：**

执行完`git add`之后，再进行提交`git commit`:
![image-20200328182755564](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/15.png)

由此，解决了冲突；

从上图中箭头所指内容可以看出：本地仓库`mygit2`中的`master`分支已经比本地远程分支`origin/master`分支多了两次提交。由于`origin/master`分支代表着远程仓库的`master`分支，也就是说本地仓库`mygit2`中的`master`分支比远程仓库的`master`分支领先了两次提交；过程如下图所示：

![image-20200407152200173](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/16.png)

* 首先`mygit`在提交`1st`的基础上进行了第`2`次提交（修改`hello.txt`），之后`mygit`将本地仓库推送（`push`）到远程仓库；

* 此时`mygit2`同样在本地仓库中进行了一次提交`3rd`（修改`hello.txt`），此时推送到远程仓库会出现错误，需要进行`pull`操作；
* 当`mygit2`执行`pull`操作，将远程仓库拉取到本地后，由于发生冲突，所以暂时不会将`origin/master`的指向更新到最新提交；随后，在`mygit2`中手动解除冲突并进行合并后，`mygit2`的状态为：

![image-20200407151529950](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/17.png)

可以看到解决冲突，手动合并后，`mygit2`已经往前更新了两次提交，而此时`origin/master`仍然指向提交`1st`。

所以解决冲突后，`mygit2`中的`master`分支会比`origin/master`分支领先两次提交；再次执行`git push`后，`origin/master`分支就会指向最新的提交点`4th`了，此时三个仓库的状态为：

![image-20200407152431572](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/18.png)

在实际开发当中，难免会出现多个人修改了**同一个文件**的情况，在进行手动合并的过程中一定要与对方协商应该如何合并，而不是**直接覆盖**；

### 3.`git pull`不同源合并冲突

所谓不同源，指的是两个仓库中的分支，根提交节点不同，如下图所示：

![image-20200410123001021](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/19.png)

假如本地`master`分支要将内容推送到远程`master`分支。由于本地`master`分支根提交节点为`1st`，远程`master`分支根提交节点为`A`，两个分支没有公共的父提交节点。所以，无法进行合并。这种情况下执行`git pull`会出现以下错误：

````
There is no tracking information for the current branch.
Please specify which branch you want to merge with.
````

> 特殊情况：假如本地仓库`mygit`是空的，也会发生不同源合并冲突。

#### 错误原因

简单来说`git pull`失败的原因有两点：

* **第一点：**两仓库中的`master`分支由于根提交节点不同，没有共同的提交历史。所以，会导致采用**三方合并原则**合并分支时，找不到公共提交节点而无法合并：

![image-20200411001626440](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/20.png)

* **第二点：**本地`master`分支没有与远程仓库中的任一分支建立关联。因此，本地`master`分支不知道将文件推送给谁，这样自然会失败；

#### 解决方案

知道了`git pull`失败的两点原因，解决方案就很清晰了，同样分为三步：

* **第一步：**执行一次`git pull`将远程仓库的分支拉取到本地：

  ![image-20200411211023424](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/21.png)

  这里的本地远程分支`origin/master`和`origin/dev`是远程分支`master`和`dev`的本地形式，代表着它们，内容上与它们一致。虽然`git pull`失败了，但是我们获得了远程分支的信息，方便进行第二步的合并操作；

* **第二步：**创建两分支的公共提交历史。此时两分支没有公共父节点，不能采用`merge`方式合并。应该采用`rebase`变基的方式，将本地`master`分支追加到远程`master`分支后面。由于本地远程分支`origin/master`与远程`master`分支有这相同的提交历史，所以可以这样写：

  ```
  git rebase origin/master
  ```

  此时，本地`master`分支的提交历史变为：`A <- B <- 1st <- 2nd`。这样本地`master`分支与远程`master`分支就有了公共的提交历史，即转换为了同源分支：

  ![image-20200411222958428](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/22.png)

  > **简写：**可以将第一步和第二步通过参数的形式合并为一步操作：
  >
  > ```
  > git pull --rebase origin master
  > ```
  >
  > ![image-20200411222302708](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/23.png)

* **第三步：**建立本地`master`分支与远程`master`分支的关联。常用的有以下三种方式：

  * **方式一：**

  ```
  //格式
  git branch --set-upstream-to=origin/<branch> master
  //用在这里具体为
  git branch --set-upstream-to=origin/master master
  ```

  该指令作用为，将本地`master`分支相关联的远程分支设置为远程`master`分支，执行该指令后，通过`git branch -vv`查看分支的关联情况，可见已顺利建立关联：

  ![image-20200411213556267](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/24.png)

  之后就可以进行推送了：

  ![image-20200411213920987](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/25.png)

  * **方式二：**

  ```
  git push -u origin master
  ```

  该指令作用为：建立本地`master`分支与远程`master`分支的联系，并进行推送：

  ![image-20200411215931617](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/26.png)

  * **方式三：**

  ```
  git push --set-upstream origin master
  ```

   作用为：建立本地`master`分支与远程`master`分支的联系，并进行推送：

  ![image-20200411221552193](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/27.png)

#### 实战演示

* 创建两个仓库`mygitA`和`mygitB`，首先在`mygitA`中的`master`分支上添加`A.txt`，提交信息记为`A`：

![image-20200410125735375](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/28.png)

* 在`mygitA`中创建并切换到`dev`分支，添加文件`C.txt`，并进行提交，提交信息记为`C`：

![image-20200410125946568](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/29.png)

* 切换回`mygitA`的`master`分支，添加文件`B.txt`，并进行提交，提交信息为`B`：

![image-20200410130141667](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/30.png)

	此时`mygitA`中两分支的状态如下：

![image-20200416153057140](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/31.png)

* 随后，建立本地仓库`mygitA`与远程仓库的关联：

  ![image-20200410130748140](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/32.png)

* 设置并推送`mygitA`的`master`分支和`dev`分支，到远程仓库的`master`分支和`dev`分支上：

  ![image-20200410232136808](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/33.png)

* 回到`mygitB`，添加文件`1st.txt`和`2st.txt`并进行两次提交`1st`和`2nd`：

  ![image-20200410232755681](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/34.png)

此时三个仓库的状态为：

![image-20200410233107154](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/35.png)

若想将`mygitB`的`master`分支推送到远程仓库的`master`分支上，按照上文的讨论，采用简写形式，可通过以下两步进行实现：

* **第一步：**通过`rebase`合并本地`master`分支与远程`master`分支：

```
git pull --rebase origin master
```

![image-20200411231327155](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/36.png)

执行完上述指令后，`mygitB`的状态为：

![image-20200411000848565](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/37.png)

* **第二步：**建立本地`master`分支与远程`master`分支的联系，并进行推送：

```
git push -u origin master
```

![image-20200411231531483](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson6/38.png)

如图所示，与远程分支建立了联系，并完成了推送；由此解决了由于不同源造成的`pull`操作冲突。
