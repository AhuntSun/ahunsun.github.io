# 11.知识点整理①

## 1.绘制三角形

原理：

![image-20200320145530157](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/1.png)

```css
//hua'jian   
.div1{
      width: 0;
      height: 0;
      border: 250px solid transparent;
      border-bottom-color: red;
    }
```

![image-20200320145440948](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/2.png)

## 2.绘制圆形

**border-radius**：`radius`为半径的意思；

只需要将`border-radius`的值设置为正方形的一半即可：

```css
    div{
      width: 200px;
      height: 200px;
      float: left;
    }
    .div1{
      background-color: red;
      border-radius: 50%;
    }
    .div2{
      background-color: blue;
      border-radius: 100px;
    }
    .div3{
      background-color: rebeccapurple;
      border-radius: 6.25em;
    }
```

![image-20200320152033823](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/3.png)

当`border-radius`的值超过正方形一半是，也会显示圆形，原因是，`css`不会处理超过指定范围的内容：

![image-20200320152352103](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/4.png)

## 3.关于em

* `1`、浏览器的默认字体大小是**16px**；

* `2`、如果元素自身**没有设置**字体大小：
	* **字体大小**默认取`body`标签的`16px`；
	* **其他属性**如“`boder`、`width`、`height`、`padding`、`margin`、`line-height`”等值按下式计算：

```
1 ÷ 父元素的font-size × 需要转换的像素值 = em值
```

**比如：**没有设置`font-size`默认使用`16px`，将`960px`转换为`em`

```
1 ÷ 16px × 960px = 60em
```

* `3`、如果元素**设置了**自身的字体大小：

	* **字体大小**按下式计算：

	```
	1 ÷ 父元素的font-size × 需要转换的像素值 = em值
	```

	* 此元素的**其他属性**，如“`border`、`width`、`height`、`padding`、`margin`、`line-height`”计算就需要按照下面的公式来计算：

	```
	1 ÷ 元素自身的font-size × 需要转换的像素值 = em值
	```

## 3.5.关于rem

r表示root，(root em)指的是设置网页中根元素：root{}的字体大小；在页面中：root{} 为html{}；如下面设置跟标签html标签的font-size为1rem，rem的值默认是浏览器字体大小16px；则在页面的其他标签中1rem = 16px：

![image-20200322160014625](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/5.png)

当根元素HTML的font-size设置为2rem（32px）时，则其他标签使用rem时，1rem = 32px

![image-20200322160218962](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/6.png)

总结：rem只会根据html中设定的font-size进行换算，不受其他父标签的影响；而使用em时，html中的font-size值会被父标签覆盖；

## 4.交换两个数

**1.临时变量法**

```javascript
let a = 3
let b = 5
let c = a
a = b
b = c
console.log(a, b)//5,3
```

**2.加减法**

```javascript
let a = 3
let b = 5
a = a + b
b = a - b//这是a那份给了b
a = a - b//此时的b值为a那份
console.log(a, b)//5,3
```

**3.数组法**

```javascript
let a = 3
let b = 5
a = [a, b]//相当于[3, 5]此时a和b变化都不会影响数组a中的元素
b = a[0]
a = a[1]
console.log(a, b)//5,3
```

**4.对象法**

```javascript
let a = 3
let b = 5
a = [a: b, b: a]//同理对象里的值为定值不受变量影响
b = a.b
a = a.a
console.log(a, b)//5,3
```

**5.数组运算法**

```javascript
let a = 3
let b = 5
a =[b, b=a][0]//根据优先级先进行b=a运算，再拿到数组的第一个元素赋值给a，注意这里的b为定值
console.log(a,b);//5,3
```

**6.按位异或法**

```javascript
let a1 = 3
let b1 = 5
a1 = a1 ^ b1
b1 = b1 ^ a1
a1 = a1 ^ b1
console.log(a1, b1);//5,3
```

![image-20200320161108836](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/7.png)

## 5.超出文本显示省略号

* 设置宽度：`width`
* 强制文本在一行显示：`white-space: nowrap`
* 隐藏溢出内容：`overflow:hidden`
* 溢出进行省略：`text-overflow:ellipsis`（省略的意思）

```css
    .box{
      width: 200px;
      border: 5px solid #000;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
```

## 6.打乱数组的顺序

```javascript
function binarySearch(arr, target){
  let start = 0;
  let end = arr.length - 1
  while(start <= end){
    let mid = Math.floor((end + start) / 2)
    if (target == arr[mid]) {
      return mid
    }else if (target < arr[mid]) {
      end = mid - 1
    }else{
      start = mid + 1
    }
  }
  return -1//找不到就返回 -1
}
let arr = [1, 2, 3, 4, 5, 6]
console.log(binarySearch(arr, 1));
console.log(binarySearch(arr, 2));
console.log(binarySearch(arr, 3));
```

## 7.href 和 src 的区别

**href：**`Hypertext Reference`：超文本引用或参照；（`link, a`）

**src：**`Source`：资源；（`img,style, script, input, iframe`）

主要区别：

```css
<body>
	<img src="smiling.png">
	<a href="smiling.png">笑一个呗</a>
</body>
```

**href**：相当是一个超链接，会建立一个通道让当前元素或者当前文档和引用资源进行联系，需要引用资源的时候就可以通过通道进行引用了；如上面的`a`标签，只有在点击`笑一个呗`时才会显示图片；

**src：**会把资源下载下来，程序遇到`src`时要下载完成具体资源后才能继续执行（好比车加油，加完油才能走）；并且会替代当前的元素，然后嵌入到文档中；如上面的`img`标签会直接显示图片；

## 8.如何用CSS水平居中元素

**行内元素设置居中：**

* **普通流inline**：

```
div{
	height: 200px;
	width: 200px;
	background: glod;
	
	text-align:center
}
```

文字排列(align)：中间；该属性会使行内块级元素（单独占一行）（`p,h1~6`等标签）水平居中，不能直接对行内元素起效果，但是可以通过给行内元素的父元素比如`body`添加该属性而使`body`标签内的行内元素水平居中；

**块级元素设置居中：**

* **普通流block：**块级元素可以设置宽和高，这是区别于行内块级元素（单独占一行）和行内元素的特点；可以采用`margin: 0 auto`使其居中；**注意**这种方法要求块级元素一定要有宽度；

	```
	div{
		height: 200px;
		width: 200px;
		background: glod;
		
		margin 0 auto;
	}
	```

**浮动元素：**

浮动元素会脱离普通的文档流，不受不同文档流中`text-align, margin`等样式的约束；此时可以采用相对定位或绝对定位的方式来实现定位：（`position: relative/absolute`）;

> `relative`与`absolute`的区别：前者相对于原来普通文档流的位置进行定位；后者相对于前一个非普通文档流（`static`）的父元素（该父元素可能是`relative`，可能是`absolute`）的位置进行定位；

**相对定位relative要依赖于原来在普通文档流中的位置，而absolute不需要，而是完全脱离了普通文档流：**

若有这样的结构：

```css
<div>
	<block></block>
</div>
```

则它们的定位方式是这样的：

![image-20200321100910542](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/8.png)

相当于是一层楼，`relative`是二楼，`absolute`是三楼，二楼要通过柱子根据在一楼的位置进行定位，三楼要依靠二楼进行定位，但三楼完全脱离了一楼，不占据一楼的任何空间；

**相对定位relative下水平居中**

```
div{
	height: 200px;
	width: 200px;
	background: glod;
	
	float = left;
	position:relative;
	left: 50%;
	margin-left: -100px;
}
```

由于`left: 50%;`移动基准为块级元素左边框，所以必须往回移动块级元素宽的一半，这就要求：

* 块级元素**要有宽**
* 并且要知道块级元素的**宽**；

**还可以采用css3的transform:translate**

```
div{
	height: 200px;
	width: 200px;
	background: glod;
	
	float = left;
	position:relative;
	left: 50%;
	transform:translateX(-50%);
}
```

这样就不需要知道元素的宽了；

**绝对定位absolute下水平居中**

有时候需要块级元素完全脱离普通文档流，不占据任何空间，因此

```
span{
	color: glod
	
	position:absolute;
	left: 0;
	right: 0;
	//如果行内元素设置为了绝对定位，那就该元素就可以像块级元素一样设置宽高;也就是可以通过普通流块级元素的方法进行居中
	margin: 0 auto;
}
```

当知道宽度时：

```
span{
	color: glod
	
	position:absolute;
	left: 0;
	right: 0;
	left: 50%
	margin-left: -60px;
}
```

也可以使用`css3`的`transform`

```
span{
	color: glod
	
	position:absolute;
	left: 0;
	right: 0;
	left: 50%
	transform:translateX(-50%);
}
```

## 9.函数作用域

函数在多个变量可用的情况下采用就近原则，使用最近的那个变量的值；

```javascript
var a = 'apple'
if(true){
	var a = 'angle'
}
console.log(a)//angle
```

上述代码中，由于`var`不存在块级作用域，所以变量`a`采用就近原则，使用`angle`的值；

**作用域表示区域；作用域链表示次序；**

## 10.CSS清除浮动

**1.clear清除浮动**

* 使用空的块级元素清除浮动，比如`P`标签：`p`，以下是为了看清楚才添加内容和样式的，实际上不添加也行；
* 只需要在浮动元素的最后添加该标签即可：

添加前：

![image-20200321105139388](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/9.png)

添加后：

![image-20200321105037590](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/10.png)

可以看到`p`标签吧父元素撑开了；

**但是会产生大量空元素，浪费资源**

**2.采用BFC的方法**

`BFC`就好像一个盒子一样，这样就可以包含住浮动的子元素了；创建`BFC`有多种方法：

* **overflow：hidden/auto**

	比如在父元素中设置`overflow:hidden`，添加`overflow`后会把浮动流也计算在内，后面多余的地方根据属性值，采用不同的处理方式：`hidden`：隐藏；

![image-20200321105431115](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/11.png)

* **给父元素设置浮动**

![image-20200321105753170](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/12.png)

该方法会影响布局，比较局限（因为父元素不一定需要浮动）

**3.添加伪元素（最好的办法）**

伪元素，相当于给文档添加了一个虚拟的元素；虚拟的元素（伪元素）可以添加到被指定元素的前面或是后面；

回想一下第一种方法：**就是在最底下添加一个空元素**，我们可以使用伪元素`after`在最底下添加这一个空元素；

![image-20200321110208915](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/13.png)

在需要清除浮动的`div`后面添加伪元素：`::after`，首先添加的元素为空所以设置：`content:'';`其次这个空元素需要是块级元素，所以设置`display:block;`最后，清除浮动采用：`clear: both;`

**可见该方法是基于第一种方法的*，也是现在最常用，最推荐的方法**

## 11.加法

原则：只要有一方是字符串，其他被加数都转换为字符串（调用toString方法）；可以说加号是字符串拼接的操作符；

![image-20200321113431378](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/14.png)

![image-20200321113449370](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/15.png)

![image-20200321113511138](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/16.png)

![image-20200321113530862](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/17.png)

![image-20200321113542762](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/18.png)

![image-20200321113606178](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/19.png)

![image-20200321113613994](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/20.png)

![image-20200321113627440](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/21.png)

## 12.CSS外边距塌陷

如图所示，只显示了`20px`的空隙，这就是常说的外边距塌陷；

![image-20200321113807355](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/22.png)

**外边距塌陷的设计初衷：**

如一段话由多个`P`标签组成，想要每个`p`标签之间和与上下两张图片之间相隔`10px`，只加了`margin-top:10px;`这个属性是不行的，与下面的图片没有空隙：

![image-20200321114110437](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/23.png)

此时只需要再给`p`标签设置`margin-bottom:10px;`即可，这便是外边距塌陷的设计初衷：

![image-20200321114428937](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/24.png)

**什么情况下会发生外边距塌陷：**

它的设计初衷是为了解决段落之间垂直方向的空隙，因此外边距塌陷只会发生在垂直方向，而不会发生在水平方向；

* **垂直方向**，不是水平方向；
* **块级元素，**不是行内元素，也不是行内块级元素；

所以只会发生在**块级元素的垂直方向上**。

**在外边距塌陷情况下，外边距的计算**

* 情况1：正数 && 正数 取**最大的数**；

![image-20200321115017031](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/25.png)

* 情况2：负数 && 负数 取**绝对值最大的数**；
* 情况3：正数 && 负数 取**相加的数**；

**当存在父子关系的时候：**

![image-20200321115701595](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/26.png)

如果是这样设置的话：不会使`B`元素距离父元素A顶部20px，而是回到了情况1

![image-20200321115520463](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/27.png)

**解决方法：**

* **方法一：绝对定位**：设置父元素`position:relative`，子元素`position:absolute`再对子元素进行定位，这样就可以了：

![image-20200321115925734](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/28.png)

* **方法二：行内块级元素**

前面提到行内块级元素不会发生外边距塌陷，所以可以把子元素通过`display:inline-block`设置为行内块级元素，这样父元素和子元素的外边距就会分开计算；

![image-20200321120210692](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/29.png)

* **方法三：相对定位**

	通过`position:relative`讲子元素设置为相对定位，然后子元素就能相对于原来`static`的位置来使用`top`定位了：**需要注意**：`relative`只是相对于原来位置进行定位，原来位置还在，使用`margin-top`时同样会发生塌陷，所以只能使用`top`属性进行定位；

![image-20200321120519013](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/30.png)

* **方法四：浮动**

让子元素左浮动或右浮动，再使用`margin-top`不过要居中就比较麻烦了；

![image-20200321120907525](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/31.png)

* **方法五：BFC**

可以通过给父元素通过`overflow:hidden`出发`BFC`使父元素不再与子元素共享外边距：不过隐藏了溢出部分比较局限。

![image-20200321121109859](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/32.png)

* **方法六：父元素添加内边距**

当父元素添加了内边距后，子元素的外边距 = 子元素的外边距 + 父元素的内边距；所以只需要设置父元素的内边距`padding`即可：

![image-20200321121356199](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/33.png)

* **方法七：添加边框**

只要子元素和父元素之间有东西隔着（子元素被压着），就不会发生外边框塌陷，这个间隔可以是边框也可以是文字：

![image-20200321121600352](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/34.png)

**此外空元素也会发生外边距塌陷：**

元素A和B之间夹着一个空元素，也会造成外边距塌陷

![image-20200321121814922](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/35.png)

## 13.this的指向

`this`的指向有四种：默认绑定、隐式绑定、硬绑定、构造函数绑定；

## 14.图片产生的空隙

`display`元素的常见分类：

![image-20200321132919413](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/36.png)

为什么会有空白：

![image-20200321133037834](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/37.png)

因为书写元素时的换行是一个空白符，标签间的空白会折叠为一个空白符这是因为`white-space`的默认值为`normal`;所以解决方法之一就是，写`img`标签时，不换行，当时这只能解决每一行的空白，且代码可读性下降；

**有三种方法**：

![image-20200321133413099](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/38.png)

可以看到只有中间的方法把垂直和水平的空隙都去除了；

了解一个概念：**基线**

![image-20200321133814329](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/39.png)

![image-20200321134336015](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/40.png)

`css`元素分为置换元素和非置换元素；`img`属于置换元素，即由其他内容来显示的；这种没有**基线**的元素底端会和元素的基线对齐；

图片和文字是绑在一起的，都是基于基线对齐的，图片下面有空隙是为了放文字；`font-size:0`这样文字没大小了，图片也就不用留位置显示文字了，所以该方法可以消除图片间的空隙；

**解决方法：让图片不使用基线对齐即可**，给图片设置`vertical-align: bottom`即可：

![image-20200321134318813](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/41.png)

给父元素设置`line-height：0`也可以不过，会出现问题：

![image-20200321134504024](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/42.png)

## 15.事件捕获和事件冒泡

按照顺序是先进行事件捕获再进行事件冒泡：

![image-20200322155404544](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/43.png)

举例：

![image-20200322155528363](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/44.png)

## 16.伪类和伪元素

![image-20200322160336710](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/45.png)

## 17.双飞翼布局

![image-20200324091725736](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/46.png)

**圣杯布局**

![image-20200324091748181](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/47.png)

**区别**

![image-20200324091811993](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/11/48.png)