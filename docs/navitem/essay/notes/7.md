# 07.Vue的生命周期与响应式原理

## 响应式原理

![image-20200522123319050](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/7/1.png)

## `Vue`的生命周期

每个 `Vue` 实例在被创建到被销毁都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 `DOM` 并在数据变化时更新 `DOM` 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。

**钩子函数**
`Vue`实例从创建到销毁的过程中 ，这些过程中会伴随着一些函数的自调用。将这些函数称为钩子函数。

为什么叫做钩子呢？原因是对于某个实例事件发生后需要响应已经预设好的代码，即某一个钩子钩住了一个实例的状态或者事件。
![img](http://ahuntsun.gitee.io/blogimagebed/img/vuepress/essay/7/2.png)

### 一、创建阶段的生命周期

### 1.`beforeCreate`

在实例初始化之后，数据观测 (`data observer`) 和 `event/watcher` 事件配置之前被调用。此时的 `data` 和 `methods` 中的 数据都还没有没初始化。

### 2.`created`

在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (`data observer`)，属性和方法的运算，`watch/event` 事件回调。也就是此时 `data` 和 `methods`已经可以初始化完成了。然而，挂载阶段还没开始，`$el` 属性目前尚不可用。 页面还没有渲染出来。

> 注意：如果要调用 `methods` 中的方法，或者操作 `data` 中的数据，最早只能在 `created` 中进行操作。

### 3.`beforeMount`

在挂载开始之前被调用。此时页面上还看不到真实的数据，因为模板在内存中编译完成了，但是还没有把模板渲染到页面中。

> 注意：在 `beforeMount` 执行的时候，页面中的元素还没有被真正替换过来，显示的是之前写的一些模板字符串。

### 4.`mounted`

实例被挂载后调用，这时 `el` 被新创建的 `vm.$el` 替换了。此时数据已经真实渲染到页面上了。

`mounted` 是实例创建期间的最后一个生命周期函数，当执行完 `mounted` 就表示，实例已经被完全创建好了。

**注意：**

`mounted` 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 `mounted` 内部使用 `vm.$nextTick`：

```javascript
mounted: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been rendered
  })
}
```

### 二、运行阶段的生命周期

### 1.`beforeUpdate`

数据更新时调用，发生在虚拟 `DOM` 打补丁之前。此时页面上数据还是旧的，但是 `data` 数据是最新的，页面还没有和最新的数据保持同步。

这里适合在更新之前访问现有的 `DOM`，比如手动移除已添加的事件监听器。

### 2.`updated`

由于数据更改导致的虚拟 `DOM` 重新渲染和打补丁，在这之后会调用该钩子。此时页面上数据已经替换成最新的。

当这个钩子被调用时，组件 `DOM` 已经更新，所以你现在可以执行依赖于 `DOM`
的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 `watcher` 取而代之。

### 三、销毁阶段的生命周期

### 1.`beforeDestroy`

实例销毁之前调用。在这一步，实例仍然完全可用。

### 2.`destroyed`

实例销毁后调用。该钩子被调用后，对应 `Vue` 实例的所有指令都被**解绑**，所有的事件监听器被**移除**，所有的子实例也都被**销毁**。