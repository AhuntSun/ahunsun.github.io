# 第三讲：本地分支的重要操作

## 前言

分支是`git`最核心的操作之一，了解分支的基本操作能够大大提高项目开发的效率。这一讲就来介绍一些分支的常见操作及其基本原理。

## 一、分支概述

在开发当中，往往需要分工合作。比如：小红开发`A`功能，小明开发`B`功能，小刚开发`C`功能。如何才能做到三者并行开发呢？`git`为我们提供的分支功能就能实现这一需求，如下图所示：

![image-20200413193720239]( http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/1.png)

在实际的开发过程中，`master`分支是用来发布项目稳定版本的。新的功能往往是在一个新建的分支上进行开发，等到新功能开发完毕并经过测试，表现稳定后，才会合并到`master`分支上进行版本更新。这样就可以在保持一款软件发行的同时，同步进行新功能的开发。

通常来说，远程仓库的`Git`分支会有如下几种：`master`分支、`test`分支、`develop`分支，除此之外可能还有紧急修复`bug`的`hotfix`分支；但是，本地的分支可以有很多；本文主要介绍`Git`本地分支的内容。

## 二、查看本地分支

### 1.`git branch`

查看当前版本库中的所有分支：

![image-20200310151203938](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/2.png)

其中的 `*` 表示当前处于的分支，可见当前处于`master`分支；

使用`git init`初始化`git`仓库时，`git`会自动创建一个`master`分支。但是，如果没有在`master`分支上进行任何提交就切换到其他分支，那么在切换分支的时候`master`分支会被销毁。并且，无法查看没有提交记录的分支，如下图所示：

![image-20200413115148907](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/3.png)

### 2.`git branch -a`

查看所有本地分支，包括本地分支和本地远程分支：

![image-20200328164045256](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/4.png)

### 3.`git branch -v`  

查看所有本地分支上最近一次的提交记录：

![image-20200413122049091](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/5.png)

但是，该指令无法查看本地远程分支：

![image-20200413123220561](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/6.png)

### 4.`git branch -r`

`-r`参数用于单独查看本地远程分支：

![image-20200413174143173](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/6.1.png)

### 5.`git branch -av`

该指令不仅可以显示所有的本地分支，包括本地远程分支，以及对应分支上的最新提交信息：

![image-20200409115958334](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/7.png)

### 6.`git branch -vv`

`-vv`参数表示查看所有本地分支与远程分支的关联情况。如图所示，本地`master`分支有本地远程分支`origin/master`与之关联，说明它已与远程`master`分支建立了关联；

![image-20200410121145929](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/8.png)

> 至于上面提到的**本地远程分支**，将在下一讲中详细介绍。

## 三、创建本地分支

### 1.`git branch <branch_name>`  

可通过上述命令创建新分支`new_branch`：

![image-20200310151357642](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/9.png)

由于是在`master`分支上创建的`new_branch`分支，所以**`new_branch`分支**与**`master`分支**有着部分**共同的提交历史**；所以，`master`分支上的文件，`new_branch`分支上都有。但是，在`new_branch`分支上添加的`new_branch`文件，不会存在于`master`分支上：

![image-20200413120006856](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/10.png)

此时两分支的状态为：

![image-20200413120509219](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/11.png)

### 2.`git branch -b <branch_name>`

通过上述命令可创建并切换到`new_branch`分支：

![image-20200413120945856](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/12.png)

如图所示，本来所在分支为`master`，并且没有`new_branch`分支。执行上述命令后，创建并切换到了`new_branch`分支上。

## 四、切换本地分支

### 1.`git checkout <branch_name>`

比如切换到`new_branch`分支：

![image-20200310151539203](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/13.png)

### 2.`git checkout -  `

切换回上次操作的分支：

![image-20200310152313013](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/14.png)

## 五、重命名本地分支

### 1.`git branch -m <oldName> <newName>`

如下图所示，将本地分支`master`重命名为`master2`：

![image-20200311115657966](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/15.png)

## 六、删除本地分支

### 1.`git branch -d new_branch`

 删除`new_branch`分支：

![image-20200310163652841](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/16.png)

**注意点：**

* 不能删除当前所处的分支；

* 当需要删除的分支上有`master`分支没有的内容，并且删除前没有进行合并（`merge`）时，会报错：

![image-20200310163934006](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/17.png)

此时可以通过**`git branch -D new_branch`** 使用参数`D`，在不合并的情况下强制**删除分支**；

## 七、合并分支

注意：这里所讲的分支指的是有公共提交节点的分支，如下图中的`dev`与`master`分支所示，提交节点`A`为它们的公共提交节点：

![image-20200411210604441](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/18.png)

当两分支没有公共提交节点，如下图所示，应采用`rebase`进行合并，后面会详细介绍：

![image-20200411210330211](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/19.png)

### 1.`git merge <branch_name>`

* 首先，创建并切换到新分支`dev`中，并为`test.txt`文件添加内容`dev1`：

  ![image-20200413213753822](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/20.png)

  **注意：**要将`dev`分支上的这一修改提交到版本库，才能进行后续合并。因为合并的是提交对象链，详情见后面讲解的合并原理：

  ![image-20200413124513814](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/21.png)

* 然后，**切换回`master`分支**，通过`git merge dev`指令，将`dev`分支中的内容合并到**当前所处**的`master`分支中；合并后`master`分支与`dev`分支上`test.txt`文件的内容达到了同步：

  ![image-20200413213934629](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/22.png)

### 2.分支合并的原则

`git`分支的合并采用的是**三方合并**的原则：找到两分支最新提交`A`和`B`的公共父节点`C`，在这三个节点的基础上合并为节点`D`。这个节点`D`就包含了两个分支上的所有内容：

![image-20200407160615973](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/23.png)

## 八、分支的本质

**分支：指向一条`commit`对象链或一条工作记录线的指针；**

快照`A~D`分别表示四次提交（`commit`），注意提交的顺序为：`A -> B -> C -> D`：

![image-20200408150401090](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/24.png)

从图中可以看到每一次提交的对象内都会保存上一次提交的`commit id`，由此可以从后往前把所有的提交（`commit`）串起来形成一条**链**（类似单向链表），**这条链就组成了一条完整的分支信息**：

* **当版本库中只有一条分支：**该分支的最新提交就包含了整条分支的所有内容，代表版本库的**当前状态**。如上图的快照`D`，里面包含了快照`A~C`中的所有内容，此时快照`D`中的内容就是整个版本库中的内容：

  ![image-20200413132342942](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/25.png)

* **当版本库中有多条分支：**每条分支上的最新提交包含了所处分支的**全部内容**，将各个分支的最新提交进行合并。合并的节点就包含了所有分支的内容，也就是**现阶段的版本库本身**；如下图中的`d1`、`m2`、`t3`分别包含了`dev`、`master`、`test`分支上的所有内容：

  ![image-20200413132409178](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/26.png)

### 1.分支 `==` 指针

情景一：

![image-20200406131416304](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/27.png)

从图中可以看到：

* **`HEAD`为一个指针：指向当前分支；**

* **`master`也为一指针：指向提交；**

情景二：

![image-20200406131503784](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/28.png)

上图中，`dev`为`master`分支上创建的新分支，可知：

* `git`在创建新分支时，文件本身不变化，只需要创建一个**代表新分支，并指向当前分支的指针**；如图中的`dev`与`master`指向同一个提交，文件没有发生任何变化；
* `HEAD`指向`dev`分支，表示当前所处分支为`dev`，相当于执行了：`git checkout -b dev` 后的状态；

> 相信你已经发现：`HEAD`是一个始终**指向当前分支**的**指针**；

### 2.`HEAD`标识符

`HEAD`文件是一个指向当前所在分支的**引用标识符**，也可以理解为一个**指针**，它与分支之间的关系是这样的：

![image-20200408000947960](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/29.png)

#### 查看`HEAD`

`HEAD`文件中并不包含`SHA1`值（每次提交的`commit ID`），而是包含一个指向另外一个引用的指针。我们可以查看`.git`目录下的`HEAD`文件：

![image-20200310172919110](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/30.png)

可见`HEAD`指向的是当前所在的`master`分支；

当我们通过`git checkout -b dev`  创建并切换到`dev`分支后，再次进入`.git`文件夹查看`HEAD`，会发现此时`HEAD`指向了`dev`：

![image-20200310173205214](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/31.png)

由此证明了`HEAD`始终指向当前分支；

当执行`git commit`命令时，`git`会创建一个`commit`对象（比如下图`D`）。并且将这个`commit`对象的`parent`指针指向`HEAD` 所指向的引用（`master`）指向的提交（也就是`C`），这样就能形成一条提交链：

![image-20200408001856063](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/32.png)

我们对于`HEAD`修改的任何操作，都会被`git reflog`完整记录下来：

![image-20200329145707276](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/33.png)

但是手动地修改`HEAD`文件，这些信息就不会被记录下来，所以十分不建议手动修改`git`相关的配置文件，而是应该尽量采用命令行的方式来修改。

#### 修改`HEAD`

实际上，我们可以通过`git`的底层命令`symbolic-ref`来实现对`HEAD`文件内容的修改；

> `git `中的命令可分为两类：**高级命令**和**底层命令**；之前介绍的`git add` 等都是高级命令；

读取：

![image-20200329150120113](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/34.png)

写入：

![image-20200329150239094](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/35.png)

要注意格式：`refs/heads/develop`；

查看`ORIG_HEAD`文件：

![image-20200329150514036](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/36.png)

里面是一个`SHA1`值，查看当前的提交信息：

![image-20200329150643422](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/37.png)

可以发现，`ORIG_HEAD`里面的`SHA1`值就是最新一次提交的`SHA1`值。

查看`FETCH_HEAD`文件：

![image-20200329150904196](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/38.png)

里面有两个信息，一个是最新提交的`commit ID`，另一个是提交信息。

所以，对于`git`而言`commit ID`是十分重要的信息，通过这个`SHA1`值可以回溯或查找需要的提交。

### 3.`git merge`原理

#### 过程图解

* **在新分支上进行提交操作**

  ![image-20200406131605850](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/39.png)

  上图表示在`dev`分支上进行了一次提交，此时：

  * 分支`master`的提交记录由：`A`、`B`和`C`组成；
  * 而分支`dev`的提交历史则由：`A`、`B`、`C`和`D`组成；

* **对两分支进行合并操作**

  ![image-20200406131708763](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/40.png)

  在`master`分支上执行：`git merge dev`将`dev`分支的内容**合并**到了`master`分支上；这种合并方式叫做：`Fast-forward`，**没有冲突**，改变的只是`master`指针的指向；

  ![image-20200310180632403](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/41.png)

#### 详细过程

**在执行合并操作前：**

* 在`master`分支上查看该分支的提交记录：

![image-20200413135649151](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/42.png)

* 在`dev`分支上查看该分支的提交记录：

![image-20200413135632944](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/43.png)

可以看到`dev`分支只是比`master`分支多进行了一次提交（`dev1`），两分支状态如下图所示：

![image-20200413140621228](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/44.png)

**执行合并操作：**

先切换到`master`分支，然后执行`git merge dev`合并`dev`分支：

![image-20200413135914872](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/45.png)

可以看到使用了`Fast-forward`方式进行合并，合并后两分支状态如下图所示：

![image-20200413140634456](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/46.png)

合并后，`HEAD`同时指向了`master`和`dev`分支；并且`master`和`dev`分支的提交历史完全一致；这就说明了：使用**`Fast-forward`（快进合并）**方式进行分支合并，只会改变`master`分支指针的指向；

### 4.`Fast-forward`

* 默认情况下，合并分支时`git`会使用`Fast-forward`模式；
* 在这种模式下，删除分支会**丢弃**分支信息；
* 进行分支合并操作时加上`--no-ff` 参数会禁止使用`Fast-forward`方式，这样会多出一次提交记录；

> `ff`表示`Fast-forward`。

具体演示如下：

#### 使用`Fast-forward`

首先，查看`master`分支上最新的`3`次提交：

![image-20200413140911195](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/47.png)

此时两分支的状态为：

![image-20200413141208043](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/48.png)

随后在`dev`分支上新增一次提交：`dev2`。查看`dev`分支上最新的`3`次提交：

![image-20200413141111031](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/49.png)

此时两个分支的状态为：

![image-20200413141246153](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/50.png)

切换回`master`分支，通过`git merge dev`合并`dev`分支，此时默认采用`Fast-forward`方式：

![image-20200413141412571](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/51.png)

可以看到合并后，`master`直接指向了`dev`的最新提交，并没有产生新的提交。合并后两分支的状态如下所示：

![image-20200413141554807](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/52.png)

由此验证了`Fast-forward`方式只会改变分支指针的指向。

#### 禁用`Fast-forward`

合并时可以通过：

```
git merge --no-ff dev
```

禁用`Fast-forward`模式。

* 继续在`dev`分支新增一次提交：`dev3`。然后查看`dev`分支上最新的`3`次提交：

  ![image-20200413142011002](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/53.png)

* 不修改`master`分支，查看其最新的`3`次提交：

  ![image-20200413142116641](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/54.png)

  此时两个分支的状态为：

  ![image-20200413142145430](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/55.png)

* 然后，在`master`分支上不使用`Fast-forward`方式合并`dev`分支。合并命令采用：

  ```
  git merge --no-ff dev
  ```

  执行后进入如下的`vim`编辑器界面，要求我们填写提交注释：

  ![image-20200413142507135](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/56.png)

这说明不使用`Fast-forward`方式合并分支，会触发了一次**提交**。填写提交注释后完成提交操作，合并完成后，查看`master`分支的提交记录：

![image-20200413142907282](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/57.png)

可以发现禁用了`Fast-forward`模式的合并会比`dev`分支多产生一次提交：`Merge branch 'dev'`，即使合并后的内容是一样的。此时两分支的状态为：

![image-20200413144533217](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/58.png)

由此验证了，禁用`Fast-forward`方式合并，会多出一个表示合并的提交记录。

### 5.合并冲突

合并的两分支只有一条分支发生了改变，并且其中一分支是基于另一分支创建的。比如上述的`master`与`dev`分支，两分支没有分岔，此时不会出现合并冲突；`git`会通过`Fast-forward`方式自动完成合并操作；

但是，当合并的两分支**都发生改变时**，即分支出现分岔，如下图所示。此时就需要解决冲突后手动合并分支了：

![image-20200413145058222](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/59.png)

具体演示如下：

#### 合并前

首先，分别对两分支上的`test.txt`文件进行修改，并分别将修改**提交**到各自的分支；

* 在`master`分支上进行新的提交：`mas3`，然后查看文件`test.txt`内容和分支提交记录：

![image-20200413150045837](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/60.png)

* 在`dev`分支上进行新的提交：`dev1`，然后查看文件`test.txt`内容和分支提交记录：

![image-20200413150139932](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/61.png)

可见两分支的提交记录只有最新一次提交不一样：

![image-20200413153145295](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/62.png)

#### 合并后

在`master`分支上，通过`git merge dev`合并`dev`分支时，会在共同修改的`test.txt`文件中出现合并冲突，如下图所示：

![image-20200413150334009](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/63.png)

出现冲突的原因为：两个分支都对同一个文件`test.txt`进行了修改，`git`合并时并不知道以哪个分支的修改为标准。所以不能采用`Fast-forward`方式自动合并，需要解决冲突，手动合并。

#### 手动合并过程

手动合并操作需要分如下三步进行：

* **第一步：选择需要保留的内容，手动解决合并冲突；**

此时进入发生合并冲突的`test.txt`文件：

![image-20200413150400943](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/64.png)

会出现典型的冲突呈现方式（此时`HEAD`指向的是`master`分支），其中：

* `<<<HEAD`与`>>>dev`之间的内容表示：两分支上`test.txt`文件的不同之处；

* `<<<HEAD`与`===`之间的内容表示：当前分支`master`对`test.txt`文件的修改；
* `===`与`>>>dev`之间的内容表示：`dev`分支对`test.txt`文件的修改；

此时只需要在`test.txt`中保留想要的内容即可，例如：将两分支对`test.txt`的修改都进行保存，删除`3、5、7`行多余的内容：

![image-20200413150810935](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/65.png)

除此之外，还可以通过`git mergetool`指令，调用`vimdiff`工具进入`vim`编辑器，来解决`test.txt`文件的冲突：

![image-20200413212456463](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/65.1.png)

![image-20200413212331710](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/65.2.png)

在实际开发中，我们很少手动进行合并，而是借助于一些工具来实现。

* **第二步：使用`git add test.txt`将手动解决冲突时对`test.txt`的修改提交到暂存区；**

编辑完毕后，可以看到此时仍然处于合并过程中（`MERGING`）。通过`git status` 查看状态，发现手动解决冲突时对`test.txt`文件的修改操作还在工作区中，需要通过`git add test.txt`将这一修改纳入暂存区，继续进行合并：

![image-20200413151548133](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/66.png)

* **第三步：通过`git commit -m '合并注释'`将手动解决冲突时对`test.txt`的修改进行提交，完成合并操作；**

如果需要填写较多的合并注释，可以通过`git commit`进入`vim`编辑器编辑。提交后，完成整个手动合并过程。

![image-20200310185125770](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/67.png)

完成手动合并分支后，查看两分支的提交历史：

* `master`分支上的提交历史：

![image-20200413152813941](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/68.png)

* `dev`分支上的提交历史：

![image-20200413152928725](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/69.png)

可以发现此时两分支转变为了可以通过`Fast forward`方式合并的形式了，如图所示：

* **手动解决冲突前：**

![image-20200413153154756](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/70.png)

* **手动解决冲突后：**

  ![image-20200413153427160](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/71.png)


#### 同步两分支

若想将`dev`和`master`分支上的内容进行同步，只需要在`dev`分支中通过`git merge master` 合并`master`分支即可。此时就可以使用`Fast-forward`方式进行合并了，合并结果如下图所示：

![image-20200413153555178](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/72.png)

**验证：**

合并后，查看`dev`分支的提交历史：

![image-20200413154132053](http://ahuntsun.gitee.io/blogimagebed/img/git/lesson3/73.png)

可以看到`HEAD`同时指向`dev`与`master`，即三个指针都指向了最新的一次提交，符合上述分析得出的结论；

经过上面的讨论，不难看出：合并分支的实质就是不同提交的合并，以及`HEAD`和分支指针的移动；
