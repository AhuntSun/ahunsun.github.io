(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{467:function(v,_,o){"use strict";o.r(_);var e=o(27),c=Object(e.a)({},(function(){var v=this,_=v.$createElement,o=v._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[o("h1",{attrs:{id:"_26-虚拟dom：虚拟dom和实际dom有何不同"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_26-虚拟dom：虚拟dom和实际dom有何不同"}},[v._v("#")]),v._v(" 26.虚拟DOM：虚拟DOM和实际DOM有何不同")]),v._v(" "),o("p",[v._v("虚拟 "),o("code",[v._v("DOM")]),v._v(" 是最近非常火的技术，两大著名前端框架 "),o("code",[v._v("React")]),v._v(" 和 "),o("code",[v._v("Vue")]),v._v(" 都使用了虚拟 "),o("code",[v._v("DOM")]),v._v("，所以我觉得非常有必要结合浏览器的工作机制对虚拟 "),o("code",[v._v("DOM")]),v._v(" 进行一次分析。当然了，"),o("code",[v._v("React")]),v._v(" 和 "),o("code",[v._v("Vue")]),v._v(" 框架本身所蕴含的知识点非常多，而且也不是我们专栏的重点，所以在这里我们还是把重心聚焦在虚拟 "),o("code",[v._v("DOM")]),v._v(" 上。")]),v._v(" "),o("p",[v._v("在本文我们会先聊聊 "),o("code",[v._v("DOM")]),v._v(" 的一些缺陷，然后在此基础上介绍虚拟 "),o("code",[v._v("DOM")]),v._v("是如何解决这些缺陷的，最后再站在双缓存和 "),o("code",[v._v("MVC")]),v._v(" 的视角来聊聊虚拟 "),o("code",[v._v("DOM")]),v._v("。理解了这些会让你对目前的前端框架有一个更加底层的认识，这也有助于你更好地理解这些前端框架。")]),v._v(" "),o("h2",{attrs:{id:"dom-的缺陷"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#dom-的缺陷"}},[v._v("#")]),v._v(" "),o("code",[v._v("DOM")]),v._v(" 的缺陷")]),v._v(" "),o("p",[v._v("通过前面一系列文章的学习，你对 "),o("code",[v._v("DOM")]),v._v(" 的生成过程应该已经有了比较深刻的理解，并且也知道了通过 "),o("code",[v._v("JavaScript")]),v._v(" 操纵 "),o("code",[v._v("DOM")]),v._v(" 是会"),o("strong",[v._v("影响到整个渲染流水线")]),v._v("的。另外，"),o("code",[v._v("DOM")]),v._v(" 还提供了一组 "),o("code",[v._v("JavaScript")]),v._v(" 接口用来遍历或者修改节点，这套接口包含了 "),o("code",[v._v("getElementById")]),v._v("、"),o("code",[v._v("removeChild")]),v._v("、"),o("code",[v._v("appendChild")]),v._v(" 等方法。")]),v._v(" "),o("p",[v._v("比如，我们可以调用"),o("code",[v._v("document.body.appendChild(node)")]),v._v("往 "),o("code",[v._v("body")]),v._v(" 节点上添加一个元素，调用该 "),o("code",[v._v("API")]),v._v(" 之后会引发一系列的连锁反应。首先渲染引擎会将 "),o("code",[v._v("node")]),v._v(" 节点添加到 "),o("code",[v._v("body")]),v._v(" 节点之上，然后触发"),o("strong",[v._v("样式计算")]),v._v("、"),o("strong",[v._v("布局")]),v._v("、"),o("strong",[v._v("绘制")]),v._v("、"),o("strong",[v._v("栅格化")]),v._v("、"),o("strong",[v._v("合成")]),v._v("等任务，我们把这一过程称为"),o("strong",[v._v("重排")]),v._v("。除了重排之外，还有可能引起重绘或者合成操作，形象地理解就是“"),o("strong",[v._v("牵一发而动全身")]),v._v("”。另外，对于 "),o("code",[v._v("DOM")]),v._v(" 的不当操作还有可能引发"),o("strong",[v._v("强制同步布局")]),v._v("和"),o("strong",[v._v("布局抖动")]),v._v("的问题，")]),v._v(" "),o("blockquote",[o("p",[v._v("**强制同步布局：**即获取"),o("code",[v._v("OffsetTop")]),v._v("等值；**布局抖动：**即将"),o("code",[v._v("OffsetTop")]),v._v("等值作为循环变量，循环获取；")])]),v._v(" "),o("p",[v._v("这些操作都会大大降低渲染效率。因此，对于 "),o("code",[v._v("DOM")]),v._v(" 的操作我们时刻都需要非常小心谨慎。")]),v._v(" "),o("p",[v._v("当然，对于简单的页面来说，其 "),o("code",[v._v("DOM")]),v._v(" 结构还是比较简单的，所以以上这些操作 "),o("code",[v._v("DOM")]),v._v(" 的问题并不会对用户体验产生太多影响。但是对于一些复杂的页面或者目前使用非常多的单页应用来说，其 "),o("code",[v._v("DOM")]),v._v(" 结构是非常复杂的，而且还需要不断地去修改 "),o("code",[v._v("DOM")]),v._v(" 树，每次操作 "),o("code",[v._v("DOM")]),v._v(" 渲染引擎都需要进行"),o("strong",[v._v("重排")]),v._v("、"),o("strong",[v._v("重绘")]),v._v("或者"),o("strong",[v._v("合成")]),v._v("等操作，因为 "),o("code",[v._v("DOM")]),v._v(" 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。")]),v._v(" "),o("p",[v._v("所以我们需要有一种方式来减少"),o("code",[v._v("JavaScript")]),v._v(" 对 "),o("code",[v._v("DOM")]),v._v(" 的操作，这时候虚拟 "),o("code",[v._v("DOM")]),v._v(" 就上场了")]),v._v(" "),o("h2",{attrs:{id:"什么是虚拟-dom"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟-dom"}},[v._v("#")]),v._v(" 什么是虚拟 "),o("code",[v._v("DOM")])]),v._v(" "),o("p",[v._v("在谈论什么是虚拟 "),o("code",[v._v("DOM")]),v._v(" 之前，我们先来看看虚拟 "),o("code",[v._v("DOM")]),v._v(" 到底要解决哪些事情。")]),v._v(" "),o("ul",[o("li",[v._v("将页"),o("strong",[v._v("面改变的内容")]),v._v("应用到虚拟 "),o("code",[v._v("DOM")]),v._v(" 上，而不是直接应用到 "),o("code",[v._v("DOM")]),v._v(" 上。")]),v._v(" "),o("li",[v._v("变化被应用到虚拟 "),o("code",[v._v("DOM")]),v._v(" 上时，虚拟 "),o("code",[v._v("DOM")]),v._v(" 并不急着去渲染页面，而仅仅是调整虚拟 "),o("code",[v._v("DOM")]),v._v(" 的内部状态，这样操作虚拟 "),o("code",[v._v("DOM")]),v._v(" 的代价就变得非常轻了。")]),v._v(" "),o("li",[v._v("在虚拟 "),o("code",[v._v("DOM")]),v._v(" 收集到足够的改变时，再把这些变化"),o("strong",[v._v("一次性应用到真实的 "),o("code",[v._v("DOM")]),v._v(" 上")]),v._v("（类似于文档碎片）。")])]),v._v(" "),o("p",[v._v("基于以上三点，我们再来看看什么是虚拟 "),o("code",[v._v("DOM")]),v._v("。为了直观理解，你可以参考下图：")]),v._v(" "),o("p",[o("img",{attrs:{src:"http://ahuntsun.gitee.io/blogimagebed/img/browser/part5/ls26/1.png",alt:""}})]),v._v(" "),o("p",[v._v("该图是我结合 "),o("code",[v._v("React")]),v._v(" 流程画的一张虚拟 "),o("code",[v._v("DOM")]),v._v(" 执行流程图，下面我们就结合这张图来分析下虚拟 "),o("code",[v._v("DOM")]),v._v(" 到底怎么运行的。")]),v._v(" "),o("ul",[o("li",[o("strong",[v._v("创建阶段")]),v._v("。首先依据 "),o("code",[v._v("JSX")]),v._v(" 和基础数据创建出来虚拟 "),o("code",[v._v("DOM")]),v._v("，它反映了真实的 "),o("code",[v._v("DOM")]),v._v("树的结构。然后由虚拟 "),o("code",[v._v("DOM")]),v._v(" 树创建出真实 "),o("code",[v._v("DOM")]),v._v(" 树，真实的 "),o("code",[v._v("DOM")]),v._v(" 树生成完后，再触发"),o("strong",[v._v("渲染流水线")]),v._v("往屏幕输出页面。")]),v._v(" "),o("li",[o("strong",[v._v("更新阶段")]),v._v("。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 "),o("code",[v._v("DOM")]),v._v(" 树；然后 "),o("code",[v._v("React")]),v._v(" 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 "),o("code",[v._v("DOM")]),v._v(" 树上；最后渲染引擎更新渲染流水线，并生成新的页面")])]),v._v(" "),o("p",[v._v("既然聊到虚拟 "),o("code",[v._v("DOM")]),v._v(" 的更新，那我们就不得不聊聊最新的"),o("code",[v._v("React Fiber")]),v._v(" 更新机制。通过上图我们知道，当有数据更新时，"),o("code",[v._v("React")]),v._v(" 会生成一个新的虚拟 "),o("code",[v._v("DOM")]),v._v("，然后拿新的虚拟 "),o("code",[v._v("DOM")]),v._v(" 和之前的虚拟 "),o("code",[v._v("DOM")]),v._v(" 进行比较，这个过程会"),o("strong",[v._v("找出变化的节点")]),v._v("，然后再将变化的节点"),o("strong",[v._v("应用")]),v._v("到 "),o("code",[v._v("DOM")]),v._v(" 上。")]),v._v(" "),o("p",[v._v("这里我们重点关注下比较过程，最开始的时候，比较两个虚拟 "),o("code",[v._v("DOM")]),v._v(" 的过程是在一个"),o("strong",[v._v("递归函数里执行")]),v._v("的，其核心算法是 "),o("code",[v._v("reconciliation")]),v._v("。通常情况下，这个比较过程执行得很快，不过当虚拟 "),o("code",[v._v("DOM")]),v._v(" 比较复杂的时候，执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿。为了解决这个问题，"),o("code",[v._v("React")]),v._v(" 团队重写了 "),o("code",[v._v("reconciliation")]),v._v(" 算法，新的算法称为 "),o("code",[v._v("Fiber reconciler")]),v._v("，之前老的算法称为 "),o("code",[v._v("Stack reconciler")]),v._v("。")]),v._v(" "),o("p",[v._v("在前面《"),o("code",[v._v("20")]),v._v(" |"),o("code",[v._v("async/await")]),v._v("：使用同步的方式去写异步代码》那篇文章中我们介绍了"),o("strong",[v._v("协程")]),v._v("，其实协程的另外一个称呼就是 "),o("code",[v._v("Fiber")]),v._v("，所以在这里我们可以把 "),o("code",[v._v("Fiber")]),v._v(" 和协程关联起来，那么所谓的 "),o("code",[v._v("Fiber reconciler")]),v._v(" 相信你也很清楚了，就是在执行算法的过程中"),o("strong",[v._v("出让主线程")]),v._v("，这样就解决了 "),o("code",[v._v("Stack reconciler")]),v._v(" 函数占用时间过久的问题。至于具体的实现过程在这里我就不详细分析了，如果感兴趣的话，你可以自行查阅相关资料进行学习。")]),v._v(" "),o("p",[v._v("了解完虚拟 "),o("code",[v._v("DOM")]),v._v(" 的大致执行流程，你应该也就知道为何需要虚拟 "),o("code",[v._v("DOM")]),v._v(" 了。不过以上都从单纯的技术视角来分析虚拟 "),o("code",[v._v("DOM")]),v._v(" 的，那接下来我们再从"),o("strong",[v._v("双缓存")]),v._v("和 "),o("code",[v._v("MVC")]),v._v(" 模型这两个视角来聊聊虚拟 "),o("code",[v._v("DOM")]),v._v("。")]),v._v(" "),o("p",[o("strong",[v._v("1. 双缓存")])]),v._v(" "),o("p",[v._v("在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的"),o("strong",[v._v("闪烁")]),v._v("。")]),v._v(" "),o("p",[v._v("而使用"),o("strong",[v._v("双缓存")]),v._v("，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。")]),v._v(" "),o("p",[v._v("在这里，你可以把虚拟 "),o("code",[v._v("DOM")]),v._v(" 看成是 "),o("code",[v._v("DOM")]),v._v(" 的一个 "),o("code",[v._v("buffer")]),v._v("，和图形显示一样，它会在"),o("strong",[v._v("完成一次完整的操作")]),v._v("之后，再把结果"),o("strong",[v._v("应用")]),v._v("到 "),o("code",[v._v("DOM")]),v._v(" 上，这样就能减少一些不必要的更新，同时还能保证 "),o("code",[v._v("DOM")]),v._v(" 的稳定输出。")]),v._v(" "),o("p",[o("strong",[v._v("2. MVC 模式")])]),v._v(" "),o("p",[v._v("到这里我们了解了虚拟 "),o("code",[v._v("DOM")]),v._v(" 是一种类似双缓存的实现。不过如果站在技术角度来理解"),o("strong",[v._v("虚拟缓存")]),v._v("，依然不能全面理解其含义。那么接下来我们再来看看虚拟 "),o("code",[v._v("DOM")]),v._v(" 在 "),o("code",[v._v("MVC")]),v._v(" 模式中所扮演的角色。")]),v._v(" "),o("p",[v._v("在各大设计模式当中，"),o("code",[v._v("MVC")]),v._v(" 是一个非常重要且应用广泛的模式，因为它能将"),o("strong",[v._v("数据")]),v._v("和"),o("strong",[v._v("视图")]),v._v("进行"),o("strong",[v._v("分离")]),v._v("，在涉及到一些复杂的项目时，能够大大减轻项目的耦合度，使得程序易于维护。")]),v._v(" "),o("p",[v._v("关于 "),o("code",[v._v("MVC")]),v._v(" 的基础结构，你可以先参考下图：")]),v._v(" "),o("p",[o("img",{attrs:{src:"http://ahuntsun.gitee.io/blogimagebed/img/browser/part5/ls26/2.png",alt:""}})]),v._v(" "),o("p",[v._v("通过上图你可以发现，"),o("code",[v._v("MVC")]),v._v(" 的整体结构比较简单，由"),o("strong",[v._v("模型")]),v._v("、"),o("strong",[v._v("视图")]),v._v("和"),o("strong",[v._v("控制器")]),v._v("组成，其核心思想就是将数据和视图分离，也就是说视图和模型之间是"),o("strong",[v._v("不允许直接通信")]),v._v("的，它们之间的通信都是通过"),o("strong",[v._v("控制器")]),v._v("来完成的。通常情况下的通信路径是视图发生了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。当然还可以根据不同的通信路径和控制器不同的实现方式，基于 "),o("code",[v._v("MVC")]),v._v(" 又能衍生出很多其他的模式，如 "),o("code",[v._v("MVP")]),v._v("、"),o("code",[v._v("MVVM")]),v._v(" 等，不过万变不离其宗，它们的基础骨架都是基于 "),o("code",[v._v("MVC")]),v._v(" 而来。")]),v._v(" "),o("p",[v._v("所以在分析基于 "),o("code",[v._v("React")]),v._v(" 或者 "),o("code",[v._v("Vue")]),v._v(" 这些前端框架时，我们需要先重点把握大的 "),o("code",[v._v("MVC")]),v._v(" 骨架结构，然后再重点查看通信方式和控制器的具体实现方式，这样我们就能从架构的视角来理解这些前端框架了。比如在分析 "),o("code",[v._v("Reac")]),v._v("t 项目时，我们可以把 "),o("code",[v._v("React")]),v._v(" 的部分看成是一个 "),o("code",[v._v("MVC")]),v._v(" 中的视图，在项目中结合 "),o("code",[v._v("Redux")]),v._v(" 就可以构建一个 "),o("code",[v._v("MVC")]),v._v(" 的模型结构，如下图所示：")]),v._v(" "),o("p",[o("img",{attrs:{src:"http://ahuntsun.gitee.io/blogimagebed/img/browser/part5/ls26/3.png",alt:""}})]),v._v(" "),o("p",[v._v("在该图中，我们可以把虚拟 "),o("code",[v._v("DOM")]),v._v(" 看成是 "),o("code",[v._v("MVC")]),v._v(" 的"),o("strong",[v._v("视图部分")]),v._v("，其"),o("strong",[v._v("控制器")]),v._v("和"),o("strong",[v._v("模型")]),v._v("都是由 "),o("code",[v._v("Redux")]),v._v(" 提供的。其具体实现过程如下：")]),v._v(" "),o("ul",[o("li",[v._v("图中的"),o("strong",[v._v("控制器")]),v._v("是用来监控 "),o("code",[v._v("DOM")]),v._v(" 的变化，一旦 "),o("code",[v._v("DOM")]),v._v(" 发生变化，控制器便会通知模型，让其更新数据；")]),v._v(" "),o("li",[v._v("模型数据更新好之后，控制器会通知"),o("strong",[v._v("视图")]),v._v("，告诉它模型的数据发生了变化；")]),v._v(" "),o("li",[v._v("视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 "),o("code",[v._v("DOM")]),v._v("；")]),v._v(" "),o("li",[v._v("新的虚拟 "),o("code",[v._v("DOM")]),v._v(" 生成好之后，就需要与之前的虚拟 "),o("code",[v._v("DOM")]),v._v(" 进行"),o("strong",[v._v("比较")]),v._v("，找出变化的节点；")]),v._v(" "),o("li",[v._v("比较出变化的节点之后，"),o("code",[v._v("React")]),v._v(" 将变化的虚拟节点"),o("strong",[v._v("应用")]),v._v("到 "),o("code",[v._v("DOM")]),v._v(" 上，这样就会触发 "),o("code",[v._v("DOM")]),v._v(" 节点的更新；")]),v._v(" "),o("li",[o("code",[v._v("DOM")]),v._v(" 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新")])]),v._v(" "),o("p",[v._v("在实际工程项目中，你需要学会分析出这各个模块，并梳理出它们之间的通信关系，这样对于任何框架你都能轻松上手了。")]),v._v(" "),o("h2",{attrs:{id:"总结"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),o("p",[v._v("好了，今天就介绍到这里，下面我来总结下本文的主要内容。")]),v._v(" "),o("p",[v._v("首先我们分析了直接操作 "),o("code",[v._v("DOM")]),v._v(" 会触发"),o("strong",[v._v("渲染流水线")]),v._v("的一系列反应，如果对 "),o("code",[v._v("DOM")]),v._v(" 操作不当的话甚至还会触发"),o("strong",[v._v("强制同步布局")]),v._v("和"),o("strong",[v._v("布局抖动")]),v._v("的问题，这也是我们在操作 "),o("code",[v._v("DOM")]),v._v(" 时需要非常小心谨慎的原因。")]),v._v(" "),o("p",[v._v("在此分析的基础上，我们介绍了虚拟 "),o("code",[v._v("DOM")]),v._v(" 是怎么解决直接操作 "),o("code",[v._v("DOM")]),v._v(" 所带来的问题以及 "),o("code",[v._v("React Fiber")]),v._v(" 更新机制。")]),v._v(" "),o("p",[v._v("要聊前端框架，就绕不开"),o("strong",[v._v("设计模式")]),v._v("，所以接下来我们又从"),o("strong",[v._v("双缓存")]),v._v("和 "),o("code",[v._v("MVC")]),v._v(" 角度分析了虚拟 "),o("code",[v._v("DOM")]),v._v("。双缓存是一种经典的思路，应用在很多场合，能解决"),o("strong",[v._v("页面无效刷新")]),v._v("和"),o("strong",[v._v("闪屏")]),v._v("的问题，虚拟 "),o("code",[v._v("DOM")]),v._v(" 就是"),o("strong",[v._v("双缓存思想")]),v._v("的一种体现。而基于 "),o("code",[v._v("MVC")]),v._v(" 的设计思想也广泛地渗透到各种场合，并且基于 "),o("code",[v._v("MVC")]),v._v(" 又衍生出了很多其他模式（如 "),o("code",[v._v("MVP")]),v._v("、"),o("code",[v._v("MVVM")]),v._v(" 等），不过万变不离其宗，它们的基础骨架都是基于 "),o("code",[v._v("MVC")]),v._v(" 而来。站在 "),o("code",[v._v("MVC")]),v._v(" 视角来理解虚拟 "),o("code",[v._v("DOM")]),v._v(" 能让你看到更为“广阔的世界”。")])])}),[],!1,null,null,null);_.default=c.exports}}]);