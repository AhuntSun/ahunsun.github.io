(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{460:function(v,_,t){"use strict";t.r(_);var s=t(27),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"_13-垃圾回收：垃圾数据如何自动回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-垃圾回收：垃圾数据如何自动回收"}},[v._v("#")]),v._v(" 13.垃圾回收：垃圾数据如何自动回收")]),v._v(" "),t("p",[v._v("有些数据被使用之后，可能就不再需要了，我们把这种数据称为"),t("strong",[v._v("垃圾数据")]),v._v("。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些"),t("strong",[v._v("垃圾数据进行回收")]),v._v("，以释放有限的内存空间；")]),v._v(" "),t("h2",{attrs:{id:"不同语言的垃圾回收策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不同语言的垃圾回收策略"}},[v._v("#")]),v._v(" 不同语言的垃圾回收策略")]),v._v(" "),t("p",[v._v("通常情况下，垃圾数据回收分为"),t("strong",[v._v("手动回收")]),v._v("和"),t("strong",[v._v("自动回收")]),v._v("两种策略。")]),v._v(" "),t("p",[v._v("如 "),t("code",[v._v("C/C++")]),v._v(" 就是使用"),t("strong",[v._v("手动回收策略")]),v._v("，何时分配内存、何时销毁内存都是由"),t("strong",[v._v("代码控制")]),v._v("的，你可以参考下面这段 "),t("code",[v._v("C")]),v._v(" 代码：")]),v._v(" "),t("div",{staticClass:"language-c line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-c"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 在堆中分配内存")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("char")]),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("*")]),v._v(" p "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v("  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("char")]),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("*")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("malloc")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("2048")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 在堆空间中分配 2048 字节的空间，并将分配后的引用地址保存到 p 中")]),v._v("\n \n "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 使用 p 指向的内存")]),v._v("\n "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n   "),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("//....")]),v._v("\n "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n \n"),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("// 使用结束后，销毁这段内存")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("free")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("p"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("；\np "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[v._v("NULL")]),v._v("；\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br"),t("span",{staticClass:"line-number"},[v._v("4")]),t("br"),t("span",{staticClass:"line-number"},[v._v("5")]),t("br"),t("span",{staticClass:"line-number"},[v._v("6")]),t("br"),t("span",{staticClass:"line-number"},[v._v("7")]),t("br"),t("span",{staticClass:"line-number"},[v._v("8")]),t("br"),t("span",{staticClass:"line-number"},[v._v("9")]),t("br"),t("span",{staticClass:"line-number"},[v._v("10")]),t("br"),t("span",{staticClass:"line-number"},[v._v("11")]),t("br")])]),t("p",[v._v("从上面这段 "),t("code",[v._v("C")]),v._v(" 代码可以看出来，要使用堆中的一块空间，我们需要先调用 "),t("code",[v._v("mallco")]),v._v(" 函数"),t("strong",[v._v("分配内存")]),v._v("，然后再使用；当不再需要这块数据的时候，就要手动调用 "),t("code",[v._v("free")]),v._v(" 函数来"),t("strong",[v._v("释放内存")]),v._v("。如果这段数据已经不再需要了，但是又没有主动调用 "),t("code",[v._v("free")]),v._v(" 函数来销毁，那么这种情况就被称为"),t("strong",[v._v("内存泄漏")]),v._v("。")]),v._v(" "),t("p",[v._v("另外一种使用的是"),t("strong",[v._v("自动垃圾回收")]),v._v("的策略，如 "),t("code",[v._v("JavaScript")]),v._v("、"),t("code",[v._v("Java")]),v._v("、"),t("code",[v._v("Python")]),v._v(" 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。")]),v._v(" "),t("p",[v._v("对于 "),t("code",[v._v("JavaScript")]),v._v(" 而言，也正是这个“自动”释放资源的特性带来了很多困惑，也让一些 "),t("code",[v._v("JavaScript")]),v._v(" 开发者误以为可以不关心内存管理，这是一个很大的误解。")]),v._v(" "),t("p",[v._v("那么在本文，我们将围绕“"),t("code",[v._v("JavaScript")]),v._v(" 的数据是如何回收的”这个话题来展开探讨。因为数据是存储在"),t("strong",[v._v("栈")]),v._v("和"),t("strong",[v._v("堆")]),v._v("两种内存空间中的，所以接下来我们就来分别介绍“"),t("strong",[v._v("栈中的垃圾数据")]),v._v("”和“"),t("strong",[v._v("堆中的垃圾数据")]),v._v("”是如何回收的。")]),v._v(" "),t("h2",{attrs:{id:"调用栈中的数据是如何回收的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调用栈中的数据是如何回收的"}},[v._v("#")]),v._v(" 调用栈中的数据是如何回收的")]),v._v(" "),t("p",[v._v("首先是调用栈中的数据，我们还是通过一段示例代码的执行流程来分析其回收机制，具体如下：")]),v._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("function")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("var")]),v._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("var")]),v._v(" b "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("name"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('" 极客邦 "')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("function")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("showName")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n      "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("var")]),v._v(" c "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('" 极客时间 "')]),v._v("\n      "),t("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("var")]),v._v(" d "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("name"),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('" 极客时间 "')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("showName")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br"),t("span",{staticClass:"line-number"},[v._v("4")]),t("br"),t("span",{staticClass:"line-number"},[v._v("5")]),t("br"),t("span",{staticClass:"line-number"},[v._v("6")]),t("br"),t("span",{staticClass:"line-number"},[v._v("7")]),t("br"),t("span",{staticClass:"line-number"},[v._v("8")]),t("br"),t("span",{staticClass:"line-number"},[v._v("9")]),t("br"),t("span",{staticClass:"line-number"},[v._v("10")]),t("br")])]),t("p",[v._v("当执行到第 "),t("code",[v._v("6")]),v._v(" 行代码时，其调用栈和堆空间状态图如下所示：")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://ahuntsun.gitee.io/blogimagebed/img/browser/part3/ls13/1.png",alt:""}})]),v._v(" "),t("p",[v._v("从图中可以看出，"),t("strong",[v._v("原始类型")]),v._v("的数据被分配到"),t("strong",[v._v("栈")]),v._v("中，"),t("strong",[v._v("引用类型")]),v._v("的数据会被分配到"),t("strong",[v._v("堆")]),v._v("中。当 "),t("code",[v._v("foo")]),v._v(" 函数执行结束之后，"),t("code",[v._v("foo")]),v._v(" 函数的"),t("strong",[v._v("执行上下文")]),v._v("会从"),t("strong",[v._v("堆")]),v._v("中"),t("strong",[v._v("被销毁")]),v._v("掉，那么它是怎么被销毁的呢？下面我们就来分析一下。")]),v._v(" "),t("p",[v._v("在上篇文章中，我们简单介绍过了，如果执行到 "),t("code",[v._v("showName")]),v._v("函数时，那么 "),t("code",[v._v("JavaScript")]),v._v(" 引擎会创建 "),t("code",[v._v("showName")]),v._v("函数的执行上下文，并将 "),t("code",[v._v("showName")]),v._v(" 函数的执行上下文压入到调用栈中，最终执行到 "),t("code",[v._v("showName")]),v._v(" 函数时，其调用栈就如上图所示。与此同时，还有一个"),t("strong",[v._v("记录当前执行状态")]),v._v("的指针（称为 "),t("code",[v._v("ESP")]),v._v("），"),t("strong",[v._v("指向")]),v._v("调用栈中 "),t("code",[v._v("showName")]),v._v(" 函数的执行上下文，"),t("strong",[v._v("表示当前正在执行 "),t("code",[v._v("showName")]),v._v(" 函数")]),v._v("。")]),v._v(" "),t("p",[v._v("接着，当"),t("code",[v._v("showName")]),v._v(" 函数执行完成之后，函数执行流程就进入了 "),t("code",[v._v("foo")]),v._v(" 函数，那这时就需要销毁 "),t("code",[v._v("showName")]),v._v(" 函数的执行上下文了。"),t("code",[v._v("ESP")]),v._v(" 这时候就帮上忙了，"),t("code",[v._v("JavaScript")]),v._v(" 会将 "),t("code",[v._v("ESP")]),v._v(" "),t("strong",[v._v("下移")]),v._v("到 "),t("code",[v._v("foo")]),v._v(" 函数的"),t("strong",[v._v("执行上下文")]),v._v("，这个"),t("strong",[v._v("下移操作")]),v._v("就是"),t("strong",[v._v("销毁")]),v._v(" "),t("code",[v._v("showName")]),v._v(" 函数执行上下文的过程。")]),v._v(" "),t("p",[v._v("你可能会有点懵，"),t("code",[v._v("ESP")]),v._v(" 指针向下移动怎么就能把 "),t("code",[v._v("showName")]),v._v(" 的执行上下文销毁了呢？具体你可以看下面这张移动 "),t("code",[v._v("ESP")]),v._v(" 前后的对比图")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://ahuntsun.gitee.io/blogimagebed/img/browser/part3/ls13/2.png",alt:""}})]),v._v(" "),t("p",[v._v("从图中可以看出，当 "),t("code",[v._v("showName")]),v._v(" 函数执行结束之后，"),t("code",[v._v("ESP")]),v._v(" 向下移动到 "),t("code",[v._v("foo")]),v._v(" 函数的执行上下文中，上面 "),t("code",[v._v("showName")]),v._v(" 的执行上下文虽然"),t("strong",[v._v("保存在栈内存")]),v._v("中，但是已经是"),t("strong",[v._v("无效内存")]),v._v("了。比如当 "),t("code",[v._v("foo")]),v._v(" 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。")]),v._v(" "),t("p",[v._v("所以说，当一个函数执行结束之后，"),t("code",[v._v("JavaScript")]),v._v(" 引擎会通过"),t("strong",[v._v("向下移动 "),t("code",[v._v("ESP")]),t("strong",[v._v("来")]),v._v("销毁")]),v._v("该函数保存在"),t("strong",[v._v("栈中的执行上下文")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"堆中的数据是如何回收的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆中的数据是如何回收的"}},[v._v("#")]),v._v(" 堆中的数据是如何回收的")]),v._v(" "),t("p",[v._v("通过上面的讲解，我想现在你应该已经知道，当上面那段代码的 "),t("code",[v._v("foo")]),v._v(" 函数执行结束之后，"),t("code",[v._v("ESP")]),v._v(" 应该是指向全局执行上下文的，那这样的话，"),t("code",[v._v("showName")]),v._v(" 函数和 "),t("code",[v._v("foo")]),v._v("函数的执行上下文就处于"),t("strong",[v._v("无效状态")]),v._v("了，不过保存在"),t("strong",[v._v("堆")]),v._v("中的两个对象依然占用着空间，如下图所示：")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://ahuntsun.gitee.io/blogimagebed/img/browser/part3/ls13/3.png",alt:""}})]),v._v(" "),t("p",[v._v("从图中可以看出，"),t("code",[v._v("1003")]),v._v(" 和 "),t("code",[v._v("1050")]),v._v(" 这两块内存依然被占用。要回收堆中的垃圾数据，就需要用到 "),t("code",[v._v("JavaScript")]),v._v(" 中的"),t("strong",[v._v("垃圾回收器")]),v._v("了。")]),v._v(" "),t("p",[v._v("所以，接下来我们就来通过 "),t("code",[v._v("Chrome")]),v._v(" 的 "),t("code",[v._v("JavaScript")]),v._v(" 引擎 "),t("code",[v._v("V8")]),v._v(" 来分析下堆中的垃圾数据是如何回收的。")]),v._v(" "),t("h2",{attrs:{id:"代际假说和分代收集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代际假说和分代收集"}},[v._v("#")]),v._v(" 代际假说和分代收集")]),v._v(" "),t("p",[v._v("不过在正式介绍 "),t("code",[v._v("V8")]),v._v(" 是如何实现回收之前，你需要先学习下"),t("strong",[v._v("代际假说")]),v._v("（"),t("code",[v._v("The Generational Hypothesis")]),v._v("）的内容，这是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的，所以很是重要。")]),v._v(" "),t("p",[t("strong",[v._v("代际假说有以下两个特点：")])]),v._v(" "),t("ul",[t("li",[v._v("第一个是大部分对象在内存中"),t("strong",[v._v("存在的时间很短")]),v._v("，简单来说，就是很多对象一经分配内存，很快就变得"),t("strong",[v._v("不可访问")]),v._v("；")]),v._v(" "),t("li",[v._v("第二个是"),t("strong",[v._v("不死的对象")]),v._v("，"),t("strong",[v._v("会活得更久")]),v._v("。")])]),v._v(" "),t("p",[v._v("其实这两个特点不仅仅适用于 "),t("code",[v._v("JavaScript")]),v._v("，同样适用于大多数的动态语言，如 "),t("code",[v._v("Java")]),v._v("、"),t("code",[v._v("Python")]),v._v(" 等。")]),v._v(" "),t("p",[v._v("有了"),t("strong",[v._v("代际假说")]),v._v("的基础，我们就可以来探讨 "),t("code",[v._v("V8")]),v._v(" 是如何实现垃圾回收的了。")]),v._v(" "),t("p",[v._v("通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。")]),v._v(" "),t("p",[v._v("所以，在 "),t("code",[v._v("V8")]),v._v(" 中会把"),t("strong",[v._v("堆")]),v._v("分为"),t("strong",[v._v("新生代")]),v._v("和"),t("strong",[v._v("老生代")]),v._v("两个区域，"),t("strong",[v._v("新生代")]),v._v("中存放的是"),t("strong",[v._v("生存时间短")]),v._v("的对象，"),t("strong",[v._v("老生代")]),v._v("中存放的"),t("strong",[v._v("生存时间久")]),v._v("的对象。")]),v._v(" "),t("p",[v._v("新生区通常只支持 "),t("code",[v._v("1～8M")]),v._v("的容量，而老生区支持的容量就"),t("strong",[v._v("大")]),v._v("很多了。对于这两块区域，"),t("code",[v._v("V8")]),v._v(" 分别使用两个不同的"),t("strong",[v._v("垃圾回收器")]),v._v("，以便更高效地实施垃圾回收。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("副垃圾回收器")]),v._v("，主要负责"),t("strong",[v._v("新生代")]),v._v("的"),t("strong",[v._v("垃圾回收")]),v._v("。")]),v._v(" "),t("li",[t("strong",[v._v("主垃圾回收器")]),v._v("，主要负责"),t("strong",[v._v("老生代")]),v._v("的"),t("strong",[v._v("垃圾回收")]),v._v("。")])]),v._v(" "),t("h2",{attrs:{id:"垃圾回收器的工作流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器的工作流程"}},[v._v("#")]),v._v(" 垃圾回收器的工作流程")]),v._v(" "),t("p",[v._v("现在你知道了 "),t("code",[v._v("V8")]),v._v(" 把堆分成两个区域——"),t("strong",[v._v("新生代")]),v._v("和"),t("strong",[v._v("老生代")]),v._v("，并分别使用两个不同的垃圾回收器。其实不论什么类型的垃圾回收器，它们都有一套共同的执行流程。")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("第一步")]),v._v("：是"),t("strong",[v._v("标记")]),v._v("空间中"),t("strong",[v._v("活动对象")]),v._v("和"),t("strong",[v._v("非活动对象")]),v._v("。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第二步")]),v._v("：是"),t("strong",[v._v("回收非活动对象")]),v._v("所占据的"),t("strong",[v._v("内存")]),v._v("。其实就是在所有的标记完成之后，统一清理内存中所有"),t("strong",[v._v("被标记为可回收")]),v._v("的对象。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第三步")]),v._v("：是做"),t("strong",[v._v("内存整理")]),v._v("。一般来说，频繁回收对象后，内存中就会存在"),t("strong",[v._v("大量不连续空间")]),v._v("，我们把这些不连续的内存空间称为"),t("strong",[v._v("内存碎片")]),v._v("。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器"),t("strong",[v._v("不会产生")]),v._v("内存碎片，比如接下来我们要介绍的"),t("strong",[v._v("副垃圾回收器")]),v._v("。")])])]),v._v(" "),t("p",[v._v("那么接下来，我们就按照这个流程来分析新生代垃圾回收器（"),t("strong",[v._v("副垃圾回收器")]),v._v("）和老生代垃圾回收器（"),t("strong",[v._v("主垃圾回收器")]),v._v("）是如何处理垃圾回收的。")]),v._v(" "),t("h2",{attrs:{id:"副垃圾回收器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#副垃圾回收器"}},[v._v("#")]),v._v(" 副垃圾回收器")]),v._v(" "),t("p",[v._v("副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数"),t("strong",[v._v("小的对象")]),v._v("都会被分配到"),t("strong",[v._v("新生区")]),v._v("，所以说这个区域虽然不大，但是"),t("strong",[v._v("垃圾回收")]),v._v("还是"),t("strong",[v._v("比较频繁")]),v._v("的。")]),v._v(" "),t("p",[v._v("新生代中用"),t("code",[v._v("Scavenge")]),v._v(" 算法来处理。所谓 "),t("code",[v._v("Scavenge")]),v._v(" 算法，是把新生代空间对半划分为两个区域，一半是"),t("strong",[v._v("对象区域")]),v._v("，一半是"),t("strong",[v._v("空闲区域")]),v._v("，如下图所示")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://ahuntsun.gitee.io/blogimagebed/img/browser/part3/ls13/4.png",alt:""}})]),v._v(" "),t("p",[v._v("新加入的对象都会存放到对象区域，当对象区域快被"),t("strong",[v._v("写满时")]),v._v("，就需要"),t("strong",[v._v("执行一次垃圾清理操作")]),v._v("。")]),v._v(" "),t("p",[v._v("在垃圾回收过程中，首先要对对象区域中的"),t("strong",[v._v("垃圾做标记")]),v._v("；标记完成之后，就进入"),t("strong",[v._v("垃圾清理阶段")]),v._v("，副垃圾回收器会把这些"),t("strong",[v._v("存活的对象复制到空闲区域中")]),v._v("，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了"),t("strong",[v._v("内存整理")]),v._v("操作，复制后空闲区域就没有内存碎片了。")]),v._v(" "),t("p",[v._v("完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的"),t("strong",[v._v("回收操作")]),v._v("，同时这种角色翻转的操作还能让新生代中的这两块区域"),t("strong",[v._v("无限重复使用")]),v._v("下去。")]),v._v(" "),t("p",[v._v("由于"),t("strong",[v._v("新生代")]),v._v("中采用的 "),t("code",[v._v("Scavenge")]),v._v(" 算法，所以每次执行清理操作时，都需要将"),t("strong",[v._v("存活的对象")]),v._v("从"),t("strong",[v._v("对象区")]),v._v("域复制到"),t("strong",[v._v("空闲区")]),v._v("域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般"),t("strong",[v._v("新生区的空间")]),v._v("会被设置得"),t("strong",[v._v("比较小")]),v._v("。")]),v._v(" "),t("p",[v._v("也正是因为新生区的空间不大，所以"),t("strong",[v._v("很容易")]),v._v("被存活的对象"),t("strong",[v._v("装满")]),v._v("整个区域。为了解决这个问题，"),t("code",[v._v("JavaScript")]),v._v(" 引擎采用了"),t("strong",[v._v("对象晋升策略")]),v._v("，也就是经过"),t("strong",[v._v("两次")]),v._v("垃圾回收"),t("strong",[v._v("依然还存活")]),v._v("的对象，会被"),t("strong",[v._v("移动到老生区")]),v._v("中。")]),v._v(" "),t("h2",{attrs:{id:"主垃圾回收器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主垃圾回收器"}},[v._v("#")]),v._v(" 主垃圾回收器")]),v._v(" "),t("p",[t("strong",[v._v("主垃圾回收器")]),v._v("主要负责"),t("strong",[v._v("老生区")]),v._v("中的"),t("strong",[v._v("垃圾回收")]),v._v("。除了新生区中"),t("strong",[v._v("晋升的对象")]),v._v("，一些"),t("strong",[v._v("大的对象")]),v._v("会直接被分配到"),t("strong",[v._v("老生区")]),v._v("。因此老生区中的对象有"),t("strong",[v._v("两个特点")]),v._v("：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("第一："),t("strong",[v._v("对象占用")]),v._v("空间大")]),v._v("；")]),v._v(" "),t("li",[t("strong",[v._v("第二："),t("strong",[v._v("对象存活")]),v._v("时间长")]),v._v("；")])]),v._v(" "),t("p",[v._v("由于老生区的对象比较大，若要在老生区中使用 "),t("code",[v._v("Scavenge")]),v._v(" 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是"),t("strong",[v._v("采用标记 - 清除")]),v._v("（"),t("code",[v._v("Mark-Sweep")]),v._v("）的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。")]),v._v(" "),t("p",[v._v("首先是"),t("strong",[v._v("标记过程阶段")]),v._v("。标记阶段就是从一组根元素开始，"),t("strong",[v._v("递归遍历")]),v._v("这组根元素，在这个遍历过程中，"),t("strong",[v._v("能到达")]),v._v("的元素称为"),t("strong",[v._v("活动对象")]),v._v("，"),t("strong",[v._v("没有到达")]),v._v("的元素就可以判断为"),t("strong",[v._v("垃圾数据")]),v._v("。")]),v._v(" "),t("p",[v._v("比如最开始的那段代码，当 "),t("code",[v._v("showName")]),v._v(" 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://ahuntsun.gitee.io/blogimagebed/img/browser/part3/ls13/5.png",alt:""}})]),v._v(" "),t("p",[v._v("从上图你可以大致看到"),t("strong",[v._v("垃圾数据")]),v._v("的"),t("strong",[v._v("标记过程")]),v._v("，当"),t("code",[v._v("showName")]),v._v(" 函数执行结束之后，"),t("code",[v._v("ESP")]),v._v(" 向下移动，指向了 "),t("code",[v._v("foo")]),v._v(" 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 "),t("code",[v._v("1003")]),v._v(" 地址的变量，也就意味着 "),t("code",[v._v("1003")]),v._v(" 这块数据为垃圾数据，被标记为红色。由于 "),t("code",[v._v("1050")]),v._v(" 这块数据被变量 "),t("code",[v._v("b")]),v._v(" 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。")]),v._v(" "),t("p",[v._v("接下来就是"),t("strong",[v._v("垃圾的清除")]),v._v("过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是"),t("strong",[v._v("清除掉红色标记数据")]),v._v("的过程，可参考下图大致理解下其清除过程：")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://ahuntsun.gitee.io/blogimagebed/img/browser/part3/ls13/6.png",alt:""}})]),v._v(" "),t("p",[v._v("上面的"),t("strong",[v._v("标记过程")]),v._v("和"),t("strong",[v._v("清除过程")]),v._v("就是"),t("strong",[v._v("标记 - 清除算法")]),v._v("，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的"),t("strong",[v._v("内存碎片")]),v._v("。而碎片过多会导致大对象无法分配到足够的"),t("strong",[v._v("连续内存")]),v._v("，于是又产生了另外一种算法——"),t("strong",[v._v("标记 - 整理")]),v._v("（"),t("code",[v._v("Mark-Compact")]),v._v("），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://ahuntsun.gitee.io/blogimagebed/img/browser/part3/ls13/7.png",alt:""}})]),v._v(" "),t("h2",{attrs:{id:"全停顿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全停顿"}},[v._v("#")]),v._v(" 全停顿")]),v._v(" "),t("p",[v._v("现在你知道了 "),t("code",[v._v("V8")]),v._v(" 是使用"),t("strong",[v._v("副垃圾回收器")]),v._v("和"),t("strong",[v._v("主垃圾回收器")]),v._v("处理垃圾回收的，不过由于 "),t("code",[v._v("JavaScript")]),v._v(" 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 "),t("code",[v._v("JavaScript")]),v._v(" 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做"),t("strong",[v._v("全停顿")]),v._v("（"),t("code",[v._v("Stop-The-World")]),v._v("）。")]),v._v(" "),t("p",[v._v("比如堆中的数据有 "),t("code",[v._v("1.5GB")]),v._v("，"),t("code",[v._v("V8")]),v._v(" 实现一次完整的垃圾回收需要 "),t("code",[v._v("1")]),v._v(" 秒以上的时间，这也是由于垃圾回收而引起 "),t("code",[v._v("JavaScript")]),v._v(" 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://ahuntsun.gitee.io/blogimagebed/img/browser/part3/ls13/8.png",alt:""}})]),v._v(" "),t("p",[v._v("在 "),t("code",[v._v("V8")]),v._v(" "),t("strong",[v._v("新生代")]),v._v("的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但"),t("strong",[v._v("老生代")]),v._v("就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 "),t("code",[v._v("200")]),v._v(" 毫秒，在这 "),t("code",[v._v("200")]),v._v(" 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 "),t("code",[v._v("JavaScript")]),v._v(" 动画，因为垃圾回收器在工作，就会导致这个动画在这 "),t("code",[v._v("200")]),v._v(" 毫秒内无法执行的，这将会造成页面的卡顿现象。")]),v._v(" "),t("p",[v._v("为了降低老生代的垃圾回收而造成的卡顿，"),t("code",[v._v("V8")]),v._v(" 将"),t("strong",[v._v("标记过程")]),v._v("分为一个个的"),t("strong",[v._v("子标记过程")]),v._v("，同时让垃圾回收标记和 "),t("code",[v._v("JavaScript")]),v._v(" 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为"),t("strong",[v._v("增量标记")]),v._v("（"),t("code",[v._v("Incremental Marking")]),v._v("）算法。如下图所示：")]),v._v(" "),t("p",[t("img",{attrs:{src:"http://ahuntsun.gitee.io/blogimagebed/img/browser/part3/ls13/9.png",alt:""}})]),v._v(" "),t("p",[v._v("使用增量标记算法，可以把一个完整的垃圾回收任务拆分为"),t("strong",[v._v("很多小的任务")]),v._v("，这些小的任务"),t("strong",[v._v("执行时间比较短")]),v._v("，可以穿插在其他的 "),t("code",[v._v("JavaScript")]),v._v(" 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。")]),v._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("p",[v._v("好了，今天就讲到这里，下面我们就来总结下今天的主要内容。")]),v._v(" "),t("p",[v._v("首先我们介绍了不同语言的垃圾回收策略，然后又说明了栈中的数据是如何回收的，最后重点讲解了 "),t("code",[v._v("JavaScript")]),v._v(" 中的垃圾回收器是如何工作的。")]),v._v(" "),t("p",[v._v("从上面的分析你也能看出来，无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。")]),v._v(" "),t("p",[v._v("其实站在工程师的视角，我们经常需要在满足需求的前提下，权衡各个指标的得失，把系统设计得尽可能适应最核心的需求。")]),v._v(" "),t("p",[v._v("生活中处理事情的原则也与之类似，古人很早就说过“两害相权取其轻，两利相权取其重”，所以与其患得患失，不如冷静地分析哪些才是核心诉求，然后果断决策牺牲哪些以使得利益最大化。")])])}),[],!1,null,null,null);_.default=a.exports}}]);